var observe = require('./lib/observe')
var diffObjectFromOldObject = require('./lib/diffObjectFromOldObject')

module.exports = exports = RPC

RPC.UID = 0;

function RPC(object){
  if (!(this instanceof RPC)) throw SyntaxError('must be called with `new`');
  
  this._object = object || {}
  
  Object.keys(RPC.prototype).forEach(function(key){
    if (key == 'constructor') return;
    if (typeof this[key] != 'function') return;
    this[key] = this[key].bind(this)
  },this)
}

RPC.create = function(remote, dnode){
  return new RPC(remote, dnode)
}

RPC.prototype = {
  constructor: RPC,
  
  set: function(path, value, callback){
    try {
      if (!path) throw TypeError("Missing path. Can't set the root object");
      observe.PathObserver.setValueAtPath(this._object, path, value);
      if (observe.PathObserver.getValueAtPath(this._object, path) != value) throw Error("Unable to set value. Maybe the object doesn't exist");
      this.deliver()
      callback && callback(null)
    } catch(e){
      if (callback) callback(e); else throw e;
    }
  },
  
  get: function(path, callback){
    try {
      callback && callback(null, observe.PathObserver.getValueAtPath(this._object, path))
    } catch(e){
      if (callback) callback(e); else throw e;
    }
  },
  
  observeMembers: function(path, onChange, callback){
    if (typeof onChange != 'function') return callback(Error('requires an onChange function'));
    
    if (!this._observers) this._observers = {};
    var observerId = ++RPC.UID;
    var observerIds = [];
    observerIds.id = observerId;
    
    var self = this;
    self._observers[observerId] = {close: function(){ observerIds.forEach(self.clearObserver, self) }};
    
    self.get(path, function(e, obj){
      
      var observerId = ++RPC.UID;
      observerIds.push(observerId);
      
      function watchMembers(obj){
        self.clearObserver(observerId, function(){
          var observer = self._observers[observerId] = new (observe.ObjectObserver)(obj, onChange, null, observerIds.id);
        })
      }
      watchMembers(obj);
      self.observe(path, function(newValue, oldValue){
        
        if (typeof oldValue != 'object' || oldValue == null) oldValue = {};
        var diff = diffObjectFromOldObject(newValue, oldValue)
        onChange(diff.added || {}, diff.removed || {}, diff.changed || {}, function getOldValue(key){return oldValue[key]}, observerIds.id)
        
        watchMembers(newValue);
      }, function(error, observerId){
        observerIds.push(observerId);
      })
      
      if (callback) callback(null, observerIds.id);
    })
  },
  
  observe: function(path, onChange, callback){
    if (!this._observers) this._observers = {};
    try {
      var observerId = ++RPC.UID;
      var observer = new (observe.PathObserver)(this._object, path, onChange, observerId);
      this._observers[observerId] = observer;
      this.get(path, function(error, value){
        onChange(value, value, observerId);
        if (callback) callback(null, observerId);
      })
    } catch(e){
      if (callback) callback(e); else throw e;
    }
  },
  
  clearObserver: function(observerId, callback){
    if (!(this._observers && observerId in this._observers)) return callback(Error('observer with id:' + observerId + ' not found'), observerId);
    var observer = this._observers[observerId];
    observer && observer.close && observer.close();
    delete this._observers[observerId];
    callback && callback(null);
  },
  
  deliver: function(){
    this._observers && Object.keys(this._observers).forEach(function(key){
      var observer = this._observers[key];
      observer && observer.deliver && observer.deliver();
    }, this)
  },
  
  close: function(){
    this._observers && Object.keys(this._observers).forEach(function(key){
      var observer = this._observers[key];
      observer && observer.close && observer.close()
      delete this._observers[key]
    }, this)
  }
}
RPC.prototype.clearObserve = RPC.prototype.clearObserver
