{
  "name": "observe-js",
  "version": "0.1.0",
  "description": "observe-js is a library for observing changes on JavaScript objects/arrays",
  "contributors": [
    {
      "name": "Sam Duvall",
      "email": "sam@rocketwhale.com"
    }
  ],
  "main": "src/observe.js",
  "directories": {
    "example": "examples",
    "test": "tests"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Polymer/ObserveJS.git"
  },
  "author": "",
  "license": "BSD",
  "readmeFilename": "README.md",
  "gitHead": "123e411687c6199c240b709d582b0e939cb14080",
  "devDependencies": {
    "chai": "*",
    "mocha": "*"
  },
  "readme": "## Learn the tech\n\n### Why observe-js?\n\nobserve-js is a library for observing changes in JavaScript data. It exposes a high-level API and uses Object.observe if available, and otherwise performs dirty-checking.\n\n### Basic Usage\n\nPath observation:\n\n```HTML\nvar observer = new PathObserver(obj, 'foo.bar.baz', function(newValue, oldValue) {\n  // respond to obj.foo.bar.baz having changed value.\n});\n```\n\nArray observation:\n\n```HTML\nvar observer = new ArrayObserver(arr, function(splices) {\n  // respond to changes to the elements of arr.\n  splices.forEach(function(splice) {\n    splice.index; // index position that the change occurred.\n    splice.removed; // an array of values representing the sequence of elements which were removed\n    splice.addedCount; // the number of elements which were inserted.\n  });\n});\n```\n\nObject observation:\n\n```HTML\nvar observer = new ObjectObserver(obj, function(added, removed, changed, getOldValueFn) {\n  // respond to changes to the obj.\n  Object.keys(added).forEach(function(property) {\n    property; // a property which has been been added to obj\n    added[property]; // its value\n  });\n  Object.keys(removed).forEach(function(property) {\n    property; // a property which has been been removed from obj\n    getOldValueFn(property); // its old value\n  });\n  Object.keys(changed).forEach(function(property) {\n    property; // a property on obj which has changed value.\n    changed[property]; // its value\n    getOldValueFn(property); // its old value\n  });\n});\n```\nForce delivery of any changes:\n```HTML\nvar obj = { id: 1 }\nvar observer = new ObjectObserve(obj, function(added, removed, changed, getOldValueFn) {\n  // react.\n});\n\nobj.id = 2;\nobserver.deliver(); // causes the callback to be invoked reporting the change in value to obj.id.\n```\n\nReset an observer to discard any previous changes:\n```HTML\nvar arr = [1, 2, 3];\nvar observer = new ArrayObserver(arr, function(splices) {\n  // react.\n});\n\narr.push(4);\nobserver.reset(); // observer forgets about prior changes\nobserver.deliver(); // because of the reset, there is nothing to report so callback is not invoked.\n```\n\nClose an observer\n```HTML\nvar obj = { foo: { bar: 2 } };\nvar observer = new PathObserver(arr, function(newValue, oldValue) {\n  // react.\n});\nobj.foo.bar = 3;\nobserver.close(); // the observer is now invalid and will never fire its callback\n```\n### About observing paths\n\n`PathObserver` allows code to react to changes to a `path value`. Details:\n\n* If a path is unreachable from the provided object, its value is `undefined`\n* If a path is empty (`''`), its value is the object provided\n* Path observation respects prototype values.\n* `PathObserver.getValueAtPath(obj, 'foo.bar.baz')` is provided in order to retrieve a `path value` without observing it.\n* `PathObserver.setValueAtPath(obj, 'foo.bar.baz')` is provided in order to set the `path value`. Setting will create a final property, but not create objects.\n\n### About observing Arrays\n\n`ArrayObserver` allows code to react to changes in the the indexed valued properties of an Array. Details:\n\n* Changes to non-indexed valued properties are not reported (e.g. arr.foo)\n* Regardless of what caused the change (e.g. splice(), arr[4] = 4, arr.length = 4), the effects are reported as splices.\n* The changes reported are the minimal set of splices required to transform the previous state of arr to the present state.\n  * `ArrayObserver.applySplices(splices, copyOfOldArray);` will do actually do this.\n* `ArrayObserver` does not respect prototype values.\n\n### About observing Objects\n\n`ObjectObserver` allows code to react to all property changes of a given object. Details:\n\n* Changes are reported as `added`, `removed`, and `changed` properties. Each is an object whose keys are property names and whose values the present value of that property on the object.\n* The forth argument (`getOldValueFn`) provided to callback, will retrieve the previous value of a given property if a change to it was reported.\n* `ObjectObserver` does not respect prototype values.\n\n## About delivery of changes\n\nChangeSummary is intended for use in environments which implement Object.observe, but it supports use in environments which do not.\n\nIf `Object.observe` is present, and observers have changes to report, their callbacks will be invoked at the end of the current turn (microtask). In a browser environment, this is generally at the end of an event.\n\nIf `Object.observe` is absent, `Platform.performMicrotaskCheckpoint()` must be called to trigger delivery of changes. If `Object.observe` is implemented, `Platform.performMicrotaskCheckpoint()` has no effect.\n",
  "_id": "observe-js@0.1.0",
  "dist": {
    "shasum": "9a0237bfce0f23e38a16733fe1500d28e1a6aeeb"
  },
  "_from": "observe-js@",
  "_resolved": "https://registry.npmjs.org/observe-js/-/observe-js-0.1.0.tgz"
}
