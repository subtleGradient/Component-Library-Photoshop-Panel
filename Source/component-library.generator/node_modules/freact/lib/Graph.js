/*jshint asi:true*/

module.exports = exports = Graph

Graph.getThis = function(){ return this }

function Graph(config, state){
  // TODO: Do something special when Graph is called inside a Graph call
  if (!(config != null && typeof config == 'object')) throw TypeError("expected a config object");
  if (!(state != null && typeof state == 'object')) throw TypeError("expected an state object");
  
  if (config.disabled) return;
  if (state.disabled) return;
  var graph = config.graph || state.graph
  if (!(graph != null && typeof graph == 'object')) throw TypeError("requires a graph config");
  if ('graph' in state) delete state.graph;
  
  init_childNodeIDs:{
    var _childNodeIDs = state._childNodeIDs
    if (!_childNodeIDs) _childNodeIDs = state._childNodeIDs = [];
    _childNodeIDs.length = 0;
  }
  init_executioners:{
    var _executioners = state._executioners
    if (!_executioners) _executioners = state._executioners = [];
    _executioners.length = 0;
  }
  init_get:{
    if (!state.getThis) state.getThis = Graph.getThis.bind(state);
  }
  init_root:{
    if (!state.getRoot) state.getRoot = state.getThis;
    var root = state.getRoot()
  }
  init_frame:{
    if ('executionIndex' in state) state.executionIndex++;
    else state.executionIndex = 0;
  }
  
  var nodeKey;
  var Execute, Execute_index, Execute_length;
  var index = 0, _childNodeCount;
  
  prep_nodes: for (nodeKey in graph){
    if (!graph.hasOwnProperty(nodeKey)) continue;
    if (typeof graph[nodeKey] != 'object') continue;
    if (graph[nodeKey] == null) continue;
    if (!('execute' in graph[nodeKey])) continue;
    
    if (!state[nodeKey]) state[nodeKey] = {getRoot:state.getRoot, getParent:state.getThis, isChild:true, key:nodeKey};
    // root[nodeKey] = state[nodeKey];
    
    if (!('execute' in graph[nodeKey])) throw Error("expected object to have an `execute` method");
    Execute = graph[nodeKey].execute
    
    if (Array.isArray(Execute)) for (Execute_index = -1, Execute_length = Execute.length; ++Execute_index < Execute_length;)
    { _childNodeIDs[index] = nodeKey; _executioners[index] = Execute[Execute_index]; index++ }
    else
    { _childNodeIDs[index] = nodeKey; _executioners[index] = Execute; index++ }
  }
  
  // state.isDirty = false;
  Execute: for (index = -1, _childNodeCount = _childNodeIDs.length; ++index < _childNodeCount;) {
    nodeKey = _childNodeIDs[index];
    Execute = _executioners[index];
    Execute(graph[nodeKey], state[nodeKey]);
    if (!state.isDirty && state[nodeKey].isDirty) state.isDirty = true;
  }
  
  return state;
}
