require('tap').test("Graph", function tap(t){
  
  var Graph = require('../lib/Graph')
  var Config = require('../lib/Config')
  
  function Node(config, state){state.execCount = (state.execCount||0) + 1}
  
  function FlarmGroup(config, state){
    if (state.graph) Graph(state, state);
    else Graph(FlarmGroup.prototype, state)
    
    if (!state.sub) state.sub = {}
    state.sub.graph = config.graph
    Graph(state.sub, state)
  }
  FlarmGroup.prototype = {
    execute:FlarmKeeper,
    graph:{
      FlarmKeeper_0:{execute:FlarmKeeper, $flarm:function(){return Math.random()}},
    }
  }
  
  
  function Get(config, state){
    return state.parent[config.nodeId][config.key]
  }
  
  function Value(config, state){
    state.value = state.parent[config.object][config.key]
  }
  
  function FlarmKeeper(config, state){
    state.config = config
    
    if (!state.executions) state.executions = 0
    state.executions++
    if (state.flarmCount == null) state.flarmCount = config.flarm || config.$flarm && config.$flarm(state) || 0;
    state.flarmCount++;
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  
  mem(noop)
  function mem(doIt){
    // if (mem.overhead == null){mem.overhead = {}; mem.overhead = mem(noop)}
    
    var memBefore = process.memoryUsage()
    doIt()
    var memAfter = process.memoryUsage()
    
    var diff = {}
    Object.keys(memBefore).forEach(function(key){
      diff[key] = memAfter[key] - memBefore[key] //- (mem.overhead[key]||0)
    })
    diff.heapPercentageUsed = memAfter.heapUsed / memAfter.heapTotal - memBefore.heapUsed / memBefore.heapTotal
    return diff
  }
  
  
  function noop(){}
  function perf(doIt){
    var time = process.hrtime()
    doIt()
    var diff = process.hrtime(time)
    var ms = (diff[0] * 1e9 + diff[1]) / 1e6
    if (perf.overhead == null){perf.overhead = 0; perf.overhead = perf(noop)}
    return ms
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  
  t.test('exists', function tap(t){
    t.ok(Graph)
    t.is(typeof Graph, 'function')
    t.end()
  })
  
  t.test('output = execute(graph, output)', function tap(t){
    var config = {graph:{}}
    var output = Graph(config, {})
    t.throws(function(){
      Graph()
    })
    t.end()
  })
  
  t.test('graph nodes execute', function tap(t){
    
    var config = {graph:{
      FlarmGroup_1:{execute:FlarmGroup, flarm:0, graph:{
        FlarmKeeper_1:{execute:FlarmKeeper, flarm:0},
        FlarmKeeper_2:{execute:FlarmKeeper, flarm:100},
      }},
    }}
    var exec1 = {id:'exec1'}
    var exec2 = {id:'exec2'}
    
    t.is(config.graph.FlarmGroup_1.flarm, 0)
    t.is(config.graph.FlarmGroup_1.graph.FlarmKeeper_1.flarm, 0)
    
    Graph(config, exec1)
    t.is(exec1.FlarmGroup_1.flarmCount, exec1.FlarmGroup_1.executions)
    t.is(exec1.FlarmGroup_1.FlarmKeeper_1.flarmCount, exec1.FlarmGroup_1.FlarmKeeper_1.config.flarm + exec1.FlarmGroup_1.FlarmKeeper_1.executions)
    
    t.is(config.graph.FlarmGroup_1.flarm, 0)
    
    Graph(config, exec2)
    t.is(exec2.FlarmGroup_1.flarmCount, exec2.FlarmGroup_1.executions)
    t.is(exec2.FlarmGroup_1.FlarmKeeper_1.flarmCount, exec2.FlarmGroup_1.FlarmKeeper_1.config.flarm + exec2.FlarmGroup_1.FlarmKeeper_1.executions)
    
    Graph(config, exec2)
    t.is(exec2.FlarmGroup_1.flarmCount, exec2.FlarmGroup_1.executions)
    t.is(exec2.FlarmGroup_1.FlarmKeeper_1.flarmCount, exec2.FlarmGroup_1.FlarmKeeper_1.config.flarm + exec2.FlarmGroup_1.FlarmKeeper_1.executions)
    
    Graph(config, exec2)
    t.is(exec2.FlarmGroup_1.flarmCount, exec2.FlarmGroup_1.executions)
    t.is(exec2.FlarmGroup_1.FlarmKeeper_1.flarmCount, exec2.FlarmGroup_1.FlarmKeeper_1.config.flarm + exec2.FlarmGroup_1.FlarmKeeper_1.executions)
    
    Graph(config, exec2)
    t.is(exec2.FlarmGroup_1.flarmCount, exec2.FlarmGroup_1.executions)
    t.is(exec2.FlarmGroup_1.FlarmKeeper_1.flarmCount, exec2.FlarmGroup_1.FlarmKeeper_1.config.flarm + exec2.FlarmGroup_1.FlarmKeeper_1.executions)
    
    t.end()
  })
  
  t.test('nodes execute in source order', function tap(t){
    
    function ts(config, state){
      var ts = process.hrtime()
      state.ts = (ts[0] * 1e9 + ts[1]) / 1e6
    }
    
    var config = {graph:{
      A:{execute:ts},
      B:{execute:Graph, graph:{
        A:{execute:ts},
        B:{execute:ts},
        C:{execute:ts},
      }},
      C:{execute:ts},
    }}
    var state = {}
    
    Graph(config, state)
    t.ok(state.A.ts < state.B.A.ts)
    t.ok(state.B.A.ts < state.B.B.ts)
    t.ok(state.B.B.ts < state.B.C.ts)
    t.ok(state.B.C.ts < state.C.ts)
    
    Graph(config, state)
    t.ok(state.A.ts < state.B.A.ts)
    t.ok(state.B.A.ts < state.B.B.ts)
    t.ok(state.B.B.ts < state.B.C.ts)
    t.ok(state.B.C.ts < state.C.ts)
    
    t.end()
  })
  
  t.test('multiple execute', function tap(t){
    
    function Foo(c,s){s.ranFoo = (s.ranFoo||0) + 1}
    function Bar(c,s){s.ranBar = (s.ranBar||0) + 1}
    function Baz(c,s){s.ranBaz = (s.ranBaz||0) + 1}
    
    var config = {graph:{
      FooNodeConfig_1:{execute:Foo},
      FooBarNodeConfig_1:{execute:[Foo, Bar]},
      FooBarBazNodeConfig_1:{execute:[Foo, Bar, Baz]},
    }}
    var state = {}
    
    Graph(config, state)
    
    t.is(state.FooNodeConfig_1.ranFoo, 1)
    t.is(state.FooNodeConfig_1.ranBar, undefined)
    t.is(state.FooNodeConfig_1.ranBaz, undefined)
    
    t.is(state.FooBarNodeConfig_1.ranFoo, 1)
    t.is(state.FooBarNodeConfig_1.ranBar, 1)
    t.is(state.FooBarNodeConfig_1.ranBaz, undefined)
    
    t.is(state.FooBarBazNodeConfig_1.ranFoo, 1)
    t.is(state.FooBarBazNodeConfig_1.ranBar, 1)
    t.is(state.FooBarBazNodeConfig_1.ranBaz, 1)
    
    Graph(config, state)
    
    t.is(state.FooNodeConfig_1.ranFoo, 2)
    t.is(state.FooNodeConfig_1.ranBar, undefined)
    t.is(state.FooNodeConfig_1.ranBaz, undefined)
    
    t.is(state.FooBarNodeConfig_1.ranFoo, 2)
    t.is(state.FooBarNodeConfig_1.ranBar, 2)
    t.is(state.FooBarNodeConfig_1.ranBaz, undefined)
    
    t.is(state.FooBarBazNodeConfig_1.ranFoo, 2)
    t.is(state.FooBarBazNodeConfig_1.ranBar, 2)
    t.is(state.FooBarBazNodeConfig_1.ranBaz, 2)
    
    t.end()
  })
  
  t.test('multiple execute executed in source order', function tap(t){
    
    function Foo(c,s){s.foo = process.hrtime()[1]}
    function Bar(c,s){s.bar = process.hrtime()[1]}
    function Baz(c,s){s.baz = process.hrtime()[1]}
    
    var config = {graph:{
      FooBarBazNodeConfig_1:{execute:[Foo, Bar, Baz]},
    }}
    var state = {}
    
    Graph(config, state)
    
    t.ok(state.FooBarBazNodeConfig_1.foo < state.FooBarBazNodeConfig_1.bar)
    t.ok(state.FooBarBazNodeConfig_1.bar < state.FooBarBazNodeConfig_1.baz)
    
    t.end()
  })
  
  t.test('getRoot', function tap(t){
    
    function GetRootFoo(){ return this.getRoot().foo }
    
    var config = {execute:[Config, Graph], $foo:function(){return Math.random()}, graph:{}}
    config.graph.Subgraph_1 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3.graph.Subgraph_4 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3.graph.Subgraph_4.graph.Subgraph_5 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3.graph.Subgraph_4.graph.Subgraph_5.graph.Subgraph_6 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3.graph.Subgraph_4.graph.Subgraph_5.graph.Subgraph_6.graph.Subgraph_7 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    config.graph.Subgraph_1.graph.Subgraph_2.graph.Subgraph_3.graph.Subgraph_4.graph.Subgraph_5.graph.Subgraph_6.graph.Subgraph_7.graph.Subgraph_8 = {execute:[Config, Graph], $foo:GetRootFoo, graph:{}}
    
    var state = {}
    
    Graph(config, state)
    
    t.is(state.foo, state.foo)
    t.is(state.Subgraph_1.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.Subgraph_4.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.Subgraph_4.Subgraph_5.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.Subgraph_4.Subgraph_5.Subgraph_6.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.Subgraph_4.Subgraph_5.Subgraph_6.Subgraph_7.foo, state.foo)
    t.is(state.Subgraph_1.Subgraph_2.Subgraph_3.Subgraph_4.Subgraph_5.Subgraph_6.Subgraph_7.Subgraph_8.foo, state.foo)
    
    t.end()
  })
  
  t.test('config.disabled == true stops all the things', function tap(t){
    function Foo(c,s){s.ranFoo = (s.ranFoo||0) + 1}
    
    var config={graph:{
      Kid_1:{execute:[Config, Foo], $random:function(){ return Math.random() }},
    }}
    var state={}
    
    t.is(state.executionCount, undefined)
    t.is(state.Kid_1, undefined)
    
    config.disabled = true
    Graph(config, state)
    t.is(state.executionIndex, undefined)
    t.is(state.Kid_1, undefined)
    
    config.disabled = false
    Graph(config, state)
    t.is(state.executionIndex, 0)
    t.is(typeof state.Kid_1.random, typeof 0)
    
    Graph(config, state)
    t.is(state.executionIndex, 1)
    
    config.disabled = true
    
    Graph(config, state)
    t.is(state.executionIndex, 1)
    
    config.disabled = false
    
    Graph(config, state)
    t.is(state.executionIndex, 2)
    
    t.end()
  })
  
  t.test('config.disabled == true stops all the things, even for subgraphs', function tap(t){
    function Foo(c,s){s.ranFoo = (s.ranFoo||0) + 1}
    
    var config={graph:{
      Subgraph_1:{execute:Graph, graph:{
        Kid_1:{execute:[Config, Foo], $random:function(){ return Math.random() }},
      }}
    }}
    var state={}
    
    t.is(state.executionCount, undefined)
    t.is(state.Subgraph_1, undefined)
    
    config.graph.Subgraph_1.disabled = true
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, undefined)
    t.is(state.Subgraph_1.Kid_1, undefined)
    
    config.graph.Subgraph_1.disabled = false
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 0)
    t.is(typeof state.Subgraph_1.Kid_1.random, typeof 0)
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 1)
    
    config.graph.Subgraph_1.disabled = true
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 1)
    
    config.graph.Subgraph_1.disabled = false
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 2)
    
    t.end()
  })
  
  t.test('state.disabled == true stops all the things, even for subgraphs', function tap(t){
    function Foo(c,s){s.ranFoo = (s.ranFoo||0) + 1}
    
    var config={graph:{
      Subgraph_1:{execute:[Config, Graph], graph:{
        Kid_1:{execute:[Config, Foo], $random:function(){ return Math.random() }},
      }}
    }}
    var state={}
    
    t.is(state.executionCount, undefined)
    t.is(state.Subgraph_1, undefined)
    
    config.graph.Subgraph_1.$disabled = function(){return true}
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, undefined)
    t.is(state.Subgraph_1.Kid_1, undefined)
    
    config.graph.Subgraph_1.$disabled = function(){return false}
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 0)
    t.is(typeof state.Subgraph_1.Kid_1.random, typeof 0)
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 1)
    
    config.graph.Subgraph_1.$disabled = function(){return true}
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 1)
    
    config.graph.Subgraph_1.$disabled = function(){return false}
    
    Graph(config, state)
    t.is(state.Subgraph_1.executionIndex, 2)
    
    t.end()
  })
  
  t.test('isDirty', function tap(t){
    throw Error("not implemented")
    t.end()
  })
  
  0 && t.test('graph must not be kept in state', function tap(t){
    throw Error("test not implemented")
    t.end()
  })
  
  ////////////////////////////////////////////////////////////////////////////////
  
  t.test('memory', function tap(t){
    
    var graph = {
      Node_1:{execute:Node},
    }
    var config = {graph:graph}
    var state = {id:'exec1'}
    var output
    
    // RSS - Resident Set Size
    function memTest(){
      output = Graph(config, state)
    }
    var memDiff
    memDiff = mem(memTest)
    t.is(state.Node_1.execCount, 1)
    memDiff = mem(memTest)
    t.is(state.Node_1.execCount, 2)
    memDiff = mem(memTest)
    memDiff = mem(memTest)
    memDiff = mem(memTest)
    memDiff = mem(memTest)
    
    t.is(memDiff.rss, 0, "must not use any memory")
    
    t.end()
  })
  
  function PassThrough(config, state){
    for (var key in config) {
      state[key] = config[key]
    }
  }
  t.test('PassThrough', function tap(t){
    
    var config = {graph:{
      PassThrough_1:{execute:PassThrough, $foo:function(state){return Math.random()}},
    }}
    var state = {}
    
    Graph(config, state)
    
    t.end()
  })
  
  false &&
  t.test('perf', function tap(t){
    
    var graph = {
      Node_1:{execute:Node},
      Node_2:{execute:Node},
      Node_3:{execute:Node},
      Node_4:{execute:Node},
      Node_5:{execute:Node},
      Node_6:{execute:Node},
      Node_7:{execute:Node},
      Node_8:{execute:Node},
      Node_9:{execute:Node},
      Node_10:{execute:Node},
      Node_11:{execute:Node},
      Node_12:{execute:Node},
      Node_13:{execute:Node},
      Node_14:{execute:Node},
      Node_15:{execute:Node},
      Node_16:{execute:Node},
      Node_17:{execute:Node},
      Node_18:{execute:Node},
      Node_19:{execute:Node},
      Node_20:{execute:Node},
    }
    var config = {graph:graph}
    var state = {id:'exec1'}
    var output
    
    // var Benchmark = require('benchmark');
    // var suite = new Benchmark.Suite;
    // 
    // suite
    // .add('output = Graph(config, state)', function(){
    //   output = Graph(config, state)
    // })
    // .on('cycle', function(event){
    //   console.log(String(event.target));
    // })
    // .on('complete', function(){
    //   // console.log('Fastest is ' + this.filter('fastest').pluck('name'));
    //   t.end()
    // })
    // .run({ 'async': true });
  })
  
})
