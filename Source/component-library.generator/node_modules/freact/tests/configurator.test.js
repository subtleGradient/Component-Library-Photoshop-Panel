require('tap').test(function tap(t){
  
  var configurator = require('../lib/configurator')
  
  t.test('exists', function tap(t){
    t.is(typeof configurator, 'function')
    t.end()
  })
  
  t.test('setter', function tap(t){
    
    var config = {abc:123}
    var state = {abc:0}
    
    configurator(config, state)
    
    t.is(state.abc, config.abc)
    
    t.end()
  })
  
  t.test('must not refer to config objects in state', function tap(t){
    
    var config = {foo:{bar:{baz:{}}}}
    var state = {}
    
    configurator(config, state)
    
    t.notOk(state.foo == config.foo)
    
    t.end()
  })
  
  t.test('state.configure(config)', function tap(t){
    
    var config = {abc:123}
    var state = {abc:0, configure:configurator}
    
    state.configure(config)
    
    t.is(state.abc, config.abc)
    
    t.end()
  })
  
  t.test('configurator.call(state, config)', function tap(t){
    
    var config = {abc:123}
    var state = {abc:0}
    
    configurator.call(state, config)
    
    t.is(state.abc, config.abc)
    
    t.end()
  })
  
  t.test('configurator(config)', function tap(t){
    
    var config = {abc:123}
    var state = configurator(config)
    
    t.is(state.abc, config.abc)
    t.isNot(configurator(config), configurator(config))
    t.isNot(state.constructor, configurator)
    
    t.end()
  })
  
  t.test('configurator.call(global, config)', function tap(t){
    
    var config = {abc:123}
    var state = configurator.call(null, config)
    
    t.is(state.abc, config.abc)
    t.isNot(configurator.call(null, config), configurator.call(null, config))
    t.isNot(state.constructor, configurator)
    
    t.end()
  })
  
  t.test('new configurator(config)', function tap(t){
    
    var config = {abc:123}
    var state = new configurator(config)
    
    t.is(state.abc, config.abc)
    t.isNot(new configurator(config, state), new configurator(config, state))
    t.is(state.constructor, configurator)
    
    t.end()
  })
  
  t.test('configurator({ fooSetter:function(foo){} })', function tap(t){
    function setter(value, oldValue, key, object){
      return this[key + 'Value'] = value
    }
    
    var config = {fooSetter:setter}
    var state = {foo:123}
    
    t.is(config.foo, undefined)
    t.is(state.foo, 123)
    
    configurator(config, state)
    
    t.is(state.foo, 123)
    
    config.foo = 456
    t.is(state.foo, 123)
    configurator(config, state)
    t.is(state.foo, 123)
    t.is(state.fooValue, 456)
    
    t.end()
  })
  
  t.test('config member configure method', function tap(t){
    
    var config = {foo:{get bar(){return Math.random()}}}
    var state = {}
    
    t.is(state.foo, undefined)
    
    configurator(config, state)
    
    t.isNot(state.foo, undefined)
    t.is(typeof state.foo.bar, 'number')
    
    var configureRan = 0
    config.foo.configure = function(_config){
      configureRan++
      t.is(_config, config.foo)
    }
    t.is(configureRan, 0);
    configurator(config, state)
    t.is(configureRan, 1);
    
    t.end()
  })
  
  t.test('config configure method', function tap(t){
    
    var config = {foo:{get bar(){return Math.random()}}}
    var state = {}
    
    t.is(state.foo, undefined)
    
    configurator(config, state)
    
    t.isNot(state.foo, undefined)
    t.is(typeof state.foo.bar, 'number')
    
    var configureRan = 0
    config.configure = function(_config){
      configureRan++
      t.is(_config, config)
    }
    t.is(configureRan, 0);
    configurator(config, state)
    t.is(configureRan, 1);
    
    t.end()
  })
  
  t.test('state.configure()', function tap(t){
    
    var state = {}
    t.is(state.config, undefined)
    state.configure = configurator
    
    state.config = {}
    state.config.abc = 123
    t.is(state.abc, undefined)
    
    state.configure()
    t.is(state.abc, state.config.abc)
    
    t.end()
  })
  
  t.test('default setter', function tap(t){
    
    var state = {config:{}, configure:configurator}
    
    state.config.foo = 123
    state.config.foo++
    state.configure()
    
    state.config.foo++
    state.config.set = function(key, value){
      state.configSetRan = {key:key, value:value}
    }
    state.set = function(){
      state.stateSetRan = true
    }
    state.configure()
    t.notOk(state.stateSetRan)
    t.ok(state.configSetRan)
    t.is(state.configSetRan.key, 'foo')
    t.is(state.configSetRan.value, state.config.foo)
    
    t.end()
  })
  
  t.test('Naïve graph→graph example', function tap(t){
    
    function Edges(edges){
      var graph = this
      for (var index=-1, edge; edge = edges[++index];) {
        graph[edge.target.id][edge.target.key] = graph[edge.source.id][edge.source.key]
      }
    }
    
    var graph = {
      Patch_1:{value:1},
      Patch_2:{value:2},
      Math_1:{
        a:111,
        b:222,
        get value(){
          return +this.a + +this.b
        }
      },
      edgesSetter:Edges,
      edges:[
        { source:{id:'Patch_1', key:'value'}, target:{key:'a', id:'Math_1'} },
        { source:{id:'Patch_2', key:'value'}, target:{key:'b', id:'Math_1'} },
      ]
    }
    
    configurator(graph, graph)
    t.is(graph.Math_1.value, graph.Patch_1.value + graph.Patch_2.value)
    
    t.end()
  })
  
  t.test('Simple graph binding example', function tap(t){
    
    function Add(a, b){ return a + b }
    
    var graph = {
      Patch_1:{value:Math.random()},
      Patch_2:{value:Math.random()},
      Math_1:{
        get a(){return graph.Patch_1.value},
        get b(){return graph.Patch_2.value},
        get value(){return this.operator(this.a, this.b)},
        operator: Add
      }
    }
    
    t.is(graph.Math_1.value, graph.Patch_1.value + graph.Patch_2.value)
    
    t.end()
  })
  
  0 && t.test('Naïve graph→state example', function tap(t){
    
    function GetProperty(id, key){ return this[id][key] }
    
    function Edges(edges){
      var state = this
      for (var index=-1, edge; edge = edges[++index];) {
        console.log(edge.source.id, edge.source.key, '→', edge.target.key, edge.target.id)
        Object.defineProperty(state[edge.target.id], edge.target.key, {get:GetProperty.bind(state, edge.source.id, edge.source.key)})
      }
    }
    
    function copyDescriptors(config){
      Object.getOwnPropertyNames(config).forEach(function(key){
        Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(config, key));
      }, this)
    }
    
    var graph = {
      Patch_1:{configure:copyDescriptors, get value(){return Math.random()}},
      Patch_2:{configure:copyDescriptors, get value(){return Math.random()}},
      Math_1:{configure:copyDescriptors,
        a:111,
        b:222,
        get value(){ return +this.a + +this.b }
      },
      edgesSetter:Edges,
      edges:[
        { source:{id:'Patch_1', key:'value'}, target:{key:'a', id:'Math_1'} },
        { source:{id:'Patch_2', key:'value'}, target:{key:'b', id:'Math_1'} },
      ]
    }
    
    var state = {
      
    }
    
    configurator(graph, state)
    t.is(state.Math_1.value, state.Patch_1.value + state.Patch_2.value)
    configurator(graph, state)
    t.is(state.Math_1.value, state.Patch_1.value + state.Patch_2.value)
    configurator(graph, state)
    t.is(state.Math_1.value, state.Patch_1.value + state.Patch_2.value)
    
    console.log(state)
    
    t.end()
  })
  
  t.test('keyPath', function tap(t){
    
    var state = {}
    var config = {
      set: function(k,v,id){
        console.log(id,k,v)
        if (id) k = id +'/'+ k;
        configurator(v, this[k], k, this)
      }
    }
    
    // var version1 = {foo:123, a:{}}
    // var version2 = {bar:123, a:{b:{}}}
    var version3 = {baz:123, a:{b:{c:{d:{e:{f:123}}}}}}
    
    configurator(config, state)
    // configurator(version1, state, '', state)
    // configurator(version2, state, '', state)
    configurator(version3, state)
    
    console.log(state)
    
    t.end()
  })
})
